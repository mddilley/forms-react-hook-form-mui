import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { github, vsDark, nightOwl } from "@code-surfer/themes";

export const theme = vsDark;

# React Hook Form + Material UI

## Mission: Make forms easy for everyone 🎉

## 🚀👩‍🚀 Discovery Day v4 👨‍🚀🚀

---

# Forms

## They sound easy. 📝 ✅ = 😃

## They aren't. ⏭️ ❎❓🔙 🚫 = 😕😅

---

# Challenges

- Validation: We want high data quality so we need to ensure valid inputs.

- Fetching options: Sometimes, options change so we have to request them from a database that keeps track of them.

- Autocomplete: Let's make long lists of options easier to enter.

- Funneling: What if a choice affects future choices? (Choose You Own Adventure 🏰🛡️🐉)

- Many options: Every library solves these problems in their own way (in no time at all 🤞).

- Bonus: Let's make forms easy for the whole team to build - regardless of proficiency with a framework or code skill.
---

<CodeSurferColumns themes={[vsDark, nightOwl]}>

<Step>

```js title="React"
import React, { useState } from "react"

const Counter = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1)
  }

  return <button onClick={handleClick}>
	          Clicked {count} {count === 1 ? 'time' : 'times'}
         </button>
}

export default Counter;
```

```js title="Svelte"
<script>
	let count = 0;

	function handleClick() {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```

</Step>

<Step>

```js 4:5 title="Declare state the React way"
import React, { useState } from "react"

const Counter = () => {
  // Declare a state variable (count) and an update function (setCount) and set an initial value
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1)
  }

  return <button onClick={handleClick}>
	          Clicked {count} {count === 1 ? 'time' : 'times'}
         </button>
}

export default Counter;
```

```js 2:5 title="Declare state the Svelte way"
<script>
    // Declare a variable and assign an initial value
    // Re-assign to update state
    // Less complex 👍
	let count = 0;

	function handleClick() {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```

</Step>

<Step>

```js 6:9 title="Handle click the React way"
import React, { useState } from "react"

const Counter = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // Call setCount() to update state with incremented value
    setCount(count + 1)
  }

  return <button onClick={handleClick}>
	          Clicked {count} {count === 1 ? 'time' : 'times'}
         </button>
}

export default Counter;
```

```js 4:8 title="Handle click event the Svelte way"
<script>
	let count = 0;

	function handleClick() {
        // Increment count and re-assign value
        // Less complex 👍
		count += 1;
	}
</script>

<button on:click={handleClick}>
	Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```

</Step>

<Step>

```js 10:13 title="Display a button the React way"
import React, { useState } from "react"

const Counter = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1)
  }

  // Use JSX (extension of JavaScript) for attributes
  return <button className="cool-button" onClick={handleClick}>
	          Clicked {count} {count === 1 ? 'time' : 'times'}
         </button>
}

export default Counter;
```

```js 9:11 title="Display a button the Svelte way"
<script>
	let count = 0;

	function handleClick() {
		count += 1;
	}
</script>

// Use plain old HTML attributes and Svelte directives
// Similar complexity 😐
<button class="cool-button" on:click={handleClick}>
	Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```

</Step>

<Step>

```js 4:9 title="Asynchronous data fetch the React way"
const { loading, error, data } = useQuery(crashQuery)

return <div>
          // Render view conditionally
          // Easy to get lost in the logical flow
          {loading && <Spinner />}
          {!!data.atd_txdot_crashes && 
          data.atd_txdot_crashes.map((crash) => <div>{crash.crash_id}</div>)}
          {error && <div>Error: {error}</div>}
       </div>   
```

```js 5:16 title="Asynchronous data fetch the Svelte way"
<script>
	const crashes = query(client, { query: crashQuery });
</script>

<!-- Await block -->
<!-- Mixes response handling with display logic 🙌 -->
<!-- More readable line-by-line -->
  {#await $crashes}
    <Spinner />
  {:then result}
    {#each result.data.atd_txdot_crashes as crash}
      <div>{crash.crash_id}
    {/each}
  {:catch error}
    Error: {error}
  {/await}
```

</Step>

</CodeSurferColumns>

---

# What I learned about Svelte
- Fast development
- More readable code
- Built-in cues for accessibility

---

# Hard things about Svelte
- It is pretty new so troubleshooting can be frustrating
- Logical blocks and directives have a learning curve
- React patterns like props and components can lead to a false sense of understanding

---

# [Demo](http://localhost:5000/) of Svelte app
## Using Vision Zero Database developed for the Vision Zero Team (test environment)


